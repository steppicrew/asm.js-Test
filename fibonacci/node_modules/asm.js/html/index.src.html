<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN"
	"http://www.w3.org/TR/html4/strict.dtd">
<html lang="en">
<head>

<meta http-equiv="content-type" content="text/html; charset=utf-8">
<title>asm.js</title>
<link rel="stylesheet" type="text/css" href="whatwg.css">
<link rel="stylesheet" type="text/css" href="github.css">
<script src="highlight.pack.js"></script>
<script src="http://code.jquery.com/jquery-1.9.1.min.js"></script>
<script>
$(document).ready(function() {
    $("div.example pre").each(function(i, e) {
        e.className = "language-javascript";
        hljs.highlightBlock(e);
    });
});
</script>
<style>
span.seq {
  border-top: solid 1px black;
}
span.meta {
  color: darkgray;
  font-size: 120%;
  margin: 0 0.2ex;
}
span.opt {
  position: relative;
  top: 0.5em;
  font-size: 80%;
  margin-left: -0.1em;
}
</style>

<body class="draft">

<div class="head">
	<h1>[TITLE]</h1>
	
	<h2 class="no-num no-toc">Working Draft â€” [DATE]</h2>
	
	<dl>
		<dt>Latest version:
		<dd><!--begin-link-->http://asmjs.org/spec/latest/<!--end-link-->
		
		<dt>Editors:
		<dd class="vcard">
			<span class="fn">David Herman</span>,
			<span class="org">Mozilla</span>,
			<span class="email">&lt;dherman@mozilla.com&gt;</span>
		<dd class="vcard">
			<span class="fn">Luke Wagner</span>,
			<span class="org">Mozilla</span>,
			<span class="email">&lt;luke@mozilla.com&gt;</span>
		<dd class="vcard">
			<span class="fn">Alon Zakai</span>,
			<span class="org">Mozilla</span>,
			<span class="email">&lt;azakai@mozilla.com&gt;</span>
	</dl>
</div>

<h2 class="no-num no-toc">Abstract</h2>

<p>This specification defines <strong>asm.js</strong>, a strict subset
of JavaScript that can be used as a low-level, efficient target
language for compilers. This sublanguage effectively describes a safe
virtual machine for memory-unsafe languages like C or C++. A
combination of static and dynamic validation allows JavaScript engines
to employ an ahead-of-time (AOT) optimizing compilation strategy for
valid asm.js code.

<h2 class="no-num no-toc">Status</h2>

<p>This specification is working towards a candidate draft for asm.js
version 1. Mozilla's SpiderMonkey JavaScript engine provides an
optimizing implementation of this draft.

<h3 class="no-num no-toc">Changelog</h2>

<ul>
<li><strong>11 October 2013</strong>
  <ul>
    <li><code>unsigned</code> is not an <code>extern</code> type
    <li>added missing <code>!</code> operator to <em>UnaryExpression</em> operators
    <li>added note about <code>~~</code> to <em>Unary Operators</em> section
    <li>added note about parenthesis agnosticism to <em>Syntax</em> section
    <li>added note about ASI to <em>Syntax</em> section
    <li>added <code>-<em>NumericLiteral</em></code> cases everywhere
    <li>function calls require explicit coercions
    <li>eliminated type <code>unknown</code>, which is no longer needed
    <li>return type of integer <code>%</code> is <code>intish</code>
  </ul>
</ul>

<h2 class="no-num no-toc">Table of Contents</h2>

<!--toc-->

<h2>Introduction</h2>

<p>This specification defines <dfn>asm.js</dfn>, a strict subset of
JavaScript that can be used as a low-level, efficient target language
for compilers. The asm.js language provides an abstraction similar to
the C/C++ virtual machine: a large binary heap with efficient loads
and stores, integer and floating-point arithmetic, first-order
function definitions, and function pointers.

<h3 class="no-toc no-num">Programming Model</h3>

<p>The asm.js programming model is built around integer and
floating-point arithmetic and a virtual heap represented as
a <a href="https://developer.mozilla.org/en-US/docs/JavaScript/Typed_arrays">typed
array</a>. While JavaScript does not directly provide constructs for
dealing with integers, they can be emulated using two tricks:

<ul>
<li>integer loads and stores can be performed using the typed arrays
API; and
<li>integer arithmetic is equivalent to the composition of
JavaScript's floating-point arithmetic operators with the integer
coercions performed by the bitwise operators.
</ul>

<p>As an example of the former, if we have
an <a href="https://developer.mozilla.org/en-US/docs/JavaScript/Typed_arrays/Int32Array">Int32Array</a>
view of the heap called <code>HEAP32</code>, then we can load the
32-bit integer at byte offset <code>p</code>:

<!--
<p>As an example of a load from the heap, if we have a 2MB heap
(i.e., <code>0x200000</code> bytes) and
an <a href="https://developer.mozilla.org/en-US/docs/JavaScript/Typed_arrays/Int32Array">Int32Array</a>
view of the heap called <code>HEAP32</code>, then we can load the
32-bit integer at byte offset <code>p</code>:
-->

<div class="example">
<pre>HEAP32[p >> 2]|0</pre>
</div>

<p>The shift converts the byte offset to a 32-bit element offset, and
the bitwise coercion ensures that an out-of-bounds access is coerced
from <code>undefined</code> back to an integer.

<!--
<p>The mask is required by asm.js in order to efficiently enforce that
the pointer is within the heap array's bounds, and the shift converts
the byte offset to a 32-bit element offset.
-->

<p>As an example of integer arithmetic, addition can be performed by
taking two integer values, adding them with the built-in addition
operator, and coercing the result back to an integer via the bitwise
or operator:

<div class="example">
<pre>(x+y)|0</pre>
</div>

<p>This programming model is directly inspired by the techniques
pioneered by the <a href="http://emscripten.org">Emscripten</a>
and <a href="http://mandreel.com">Mandreel</a> compilers.

<h3 class="no-num no-toc">Validation</h3>

<p>The asm.js sub-language is defined by a
<a href="#validation-rules">static type system</a> that can be checked
at JavaScript parse time. Validation of asm.js code is designed to be
"pay-as-you-go" in that it is never performed on code that does not
request it. An asm.js <dfn>module</dfn> requests validation by means
of a
special <a href="http://ecma-international.org/ecma-262/5.1/#sec-14.1">prologue
directive</a>, similar to that of ECMAScript Edition
5's <a href="http://ecma-international.org/ecma-262/5.1/#sec-10.1.1">strict
mode</a>:

<div class="example">
<pre>function MyAsmModule() {
    "use asm";
    // module body
}</pre>
</div>

<p>This explicit directive allows JavaScript engines to avoid
performing pointless and potentially costly validation on other
JavaScript code, and to report validation errors in developer consoles
only where relevant.

<h3 class="no-num no-toc">Ahead-Of-Time Compilation</h3>

<p>Because asm.js is a strict subset of JavaScript, this specification
only defines the validation logic&mdash;the execution semantics is
simply that of JavaScript. However, validated asm.js is amenable to
ahead-of-time (AOT) compilation. Moreover, the code generated by an
AOT compiler can be quite efficient, featuring:

<ul>
<li>unboxed representations of integers and floating-point numbers;
<li>absence of runtime type checks;
<li>absence of garbage collection; and
<li>efficient heap loads and stores (with implementation strategies varying by platform).
</ul>

<p>Code that fails to validate must fall back to execution by
traditional means, e.g., interpretation and/or just-in-time (JIT)
compilation.

<!--
Moreover, the low-level nature of validated asm.js code makes it
possible for AOT implementations to perform aggressive optimizations
without profiling, heuristics, or dynamic deoptimization or
recompilation.
-->

<h3 class="no-num no-toc">Linking</h3>

<p>Using an asm.js module requires calling its function to obtain an
object containing the module's exports; this is known
as <dfn>linking</dfn>. An asm.js module can also be given access to
standard libraries and custom JavaScript functions through linking. An
AOT implementation must perform certain <a href="#linking-0">dynamic
checks</a> to check compile-time assumptions about the linked
libraries in order to make use of the compiled code.

<p>This figure depicts a simple architecture of an AOT implementation
that otherwise employs a simple interpreter. If either dynamic or
static validation fails, the implementation must fall back to the
interpreter. But if both validations succeed, calling the module
exports executes the binary executable code generated by AOT
compilation.

<figure class="diagrams">
<a href="aot.png"><img src="aot.png" width="800" height="200"></a>
</figure>

<h3 class="no-num no-toc">External Code and Data</h3>

<p>Within an asm.js module, all code is fully statically typed and
limited to the very restrictive asm.js dialect. However, it is
possible to interact with recognized standard JavaScript libraries and
even custom dynamic JavaScript functions.

<p>An asm.js module can take up to three optional parameters,
providing access to external JavaScript code and data:

<ul>
<li>a <dfn>standard library</dfn> object, providing access to a
limited subset of the JavaScript <a href="#standard-library">standard
libraries</a>;
<li>a <dfn>foreign function interface</dfn> (FFI), providing access to
custom external JavaScript functions; and
<li>a <dfn>heap buffer</dfn>, providing a
single <a href="https://developer.mozilla.org/en-US/docs/JavaScript/Typed_arrays/ArrayBuffer"><code>ArrayBuffer</code></a>
to act as the asm.js heap.
</ul>

<p>These objects allow asm.js to call into external JavaScript (and to
share its heap buffer with external JavaScript). Conversely, the
exports object returned from the module allows external JavaScript to
call into asm.js.

<p>So in the general case, an asm.js module declaration looks like:

<div class="example">
<pre>function MyAsmModule(stdlib, foreign, heap) {
    "use asm";

    // module body...

    return {
        export1: f1,
        export2: f2,
        // ...
    };
}
</div>

<p>Function parameters in asm.js are provided a type annotation by
means of an explicit coercion on function entry:

<div class="example">
<pre>function diag(x, y) {
    x = +x; // x has type double
    y = +y; // y has type double
    return +sqrt(square(x) + square(y));
}</pre>
</div>

<p>These annotations serve two purposes: first, to provide the
function's type signature so that the validator can enforce that all
calls to the function are well-typed; second, to ensure that even if
the function is exported and called by external JavaScript, its
arguments are dynamically coerced to the expected type. This ensures
that an AOT implementation can use unboxed value representations,
knowing that once the dynamic coercions have completed, the function
body never needs any runtime type checks.

<h3 class="no-num no-toc">Putting It All Together</h3>

<p>The following is a simple but complete example of an asm.js module.

<!--
<p>As a simple example, the following module imports the
standard <code>Math.sqrt</code> library function. At link time, the
engine must verify that the function extracted
from <code>stdlib.Math.sqrt</code> is actually the original
<code>Math.sqrt</code> function of the JavaScript standard library:
-->

<div class="example">
<pre>function DiagModule(stdlib) {
    "use asm";

    var sqrt = stdlib.Math.sqrt;

    function square(x) {
        x = +x;
        return +(x*x);
    }

    function diag(x, y) {
        x = +x;
        y = +y;
        return +sqrt(square(x) + square(y));
    }

    return { diag: diag };
}</pre>
</div>

<p>In a JavaScript engine that supports AOT compilation of asm.js,
calling the module on a true global object would produce a fully
compiled exports object:

<div class="example">
<pre>var fast = DiagModule(window);     // produces AOT-compiled version
console.log(fast.diag(3, 4));      // 5</pre>
</div>

<p>By contrast, calling the module on a standard library object
containing something other than the true <code>Math.sqrt</code> would
fail to produce compiled code:

<div class="example">
<pre>var bogusGlobal = {
    Math: {
        sqrt: function(x) { return x * 2; }
    }
};

var slow = DiagModule(bogusGlobal); // produces purely-interpreted version
console.log(slow.diag(3, 4));       // 50</pre>
</div>


<h2>Types</h2>

<p>Validation of an asm.js module relies on a static type system that
classifies and constrains the syntax. This section defines the types
used by the validation logic.

<h3>Value Types</h3>

<p>Validation in asm.js limits JavaScript programs to only use operations
that can be mapped closely to efficient data representations and
machine operations of modern architectures, such as 32-bit integers
and integer arithmetic.

<p>The types of asm.js values are inter-related by a subtyping
relation, which can be represented pictorially:

<figure class="diagrams">
<a href="subtypes.png"><img src="subtypes.png" width="620" height="347"></a>
</figure>

<p>The light boxes represent arbitrary JavaScript values that may flow
freely between asm.js code and external JavaScript code.

<p>The dark boxes represent types that are disallowed from escaping
into external (i.e., non-asm.js) JavaScript code. (These values can be
given efficient, unboxed representations in optimized asm.js
implementations that would be unsound if they were allowed to escape.)

<p>The meta-variables &sigma; and &tau; are used to stand for value
types.

<h4>void</h4>

<p>The <dfn><code>void</code></dfn> type is the type of functions that
are not supposed to return any useful value. As JavaScript functions,
they produce the <code>undefined</code> value, but asm.js code is not
allowed to make use of this value; functions with return
type <code>void</code> can only be called for effect.

<h4>double</h4>

<p>The <dfn><code>double</code></dfn> type is the type of ordinary
JavaScript double-precision floating-point numbers.

<h4>signed</h4>

<p>The <dfn><code>signed</code></dfn> type is the type of signed
32-bit integers. While there is no direct concept of integers in
JavaScript, 32-bit integers can be represented as doubles, and integer
operations can be performed with JavaScript arithmetic, relational,
and bitwise operators.

<h4>unsigned</h4>

<p>The <dfn><code>unsigned</code></dfn> type is the type of unsigned
32-bit integers. Again, these are not a first-class concept in
JavaScript, but can be represented as floating-point numbers.

<h4>int</h4>

<p>The <dfn><code>int</code></dfn> type is the type of 32-bit integers
where the signedness is not known. In asm.js, the type of a variable
never has a known signedness. This allows them to be compiled as
32-bit integer registers and memory words. However, this
representation creates an overlap between signed and unsigned numbers
that causes an ambiguity in determining which JavaScript number they
represent. For example, the bit pattern <code>0xffffffff</code> could
represent 4294967295 or -1, depending on the signedness. For this
reason, values of the <code>int</code> type are disallowed from
escaping into external (non-asm.js) JavaScript code.

<h4>fixnum</h4>

<p>The <dfn><code>fixnum</code></dfn> type is the type of integers in the
range [0, 2<sup>31</sup>)&mdash;that is, the range of integers such
that an unboxed 32-bit representation has the same value whether it is
interpreted as signed or unsigned.


<h4>intish</h4>

<p>Even though JavaScript only supports floating-point arithmetic,
most operations can simulate integer arithmetic by coercing their
result to an integer. For example, adding two integers may overflow
beyond the 32-bit range, but coercing the result back to an integer
produces the same 32-bit integer as integer addition in, say, C.

<p>The <dfn><code>intish</code></dfn> type represents the result of a
JavaScript integer operation that must be coerced back to an integer
with an explicit coercion
(<a href="http://ecma-international.org/ecma-262/5.1/#sec-9.5"><em>ToInt32</em></a>
for signed integers
and <a href="http://ecma-international.org/ecma-262/5.1/#sec-9.6"><em>ToUint32</em></a>
for unsigned integers). Validation requires all <code>intish</code>
values to be immediately passed to an operator or standard library
that performs the appropriate coercion or else dropped via an
expression statement. This way, each integer operation can be
compiled directly to machine operations.

<p>The one operator that does not support this approach is
multiplication. (Multiplying two large integers can result in a large
enough double that some lower bits of precision are lost.) So asm.js
does not support applying the multiplication operator to integer
operands. Instead, the
proposed <a href="https://mail.mozilla.org/pipermail/es-discuss/2012-November/026126.html"><code>Math.imul</code></a>
function is recommended as the proper means of implementing integer
multiplication.


<h4>doublish</h4>

Similar to <code>intish</code>, the <dfn><code>doublish</code></dfn>
type represents operations that are expected to produce
a <code>double</code> but may produce additional junk that must be
coerced back to a number
via <a href="http://ecma-international.org/ecma-262/5.1/#sec-9.3"><em>ToNumber</em></a>. In
particular, reading out of bounds from a typed array
produces <code>undefined</code>, and calling FFI functions may produce
arbitrary JavaScript values.

<h4>extern</h4>

The abstract <dfn><code>extern</code></dfn> type represents the root
of all types that can escape back into external JavaScript&mdash;in
other words, the light boxes in the above diagram.

<h3>Global Types</h3>

<p>Variables and functions defined at the top-level scope of an asm.js
module can have additional types beyond
the <a href="#value-types">value types</a>. These include:

<ul>
<li>value types &tau;;
<li><a href="https://developer.mozilla.org/en-US/docs/JavaScript/Typed_arrays/ArrayBufferView"><code>ArrayBufferView</code></a> types <code>Int<em>n</em>Array</code>, <code>Uint<em>n</em>Array</code>, and <code>Float<em>n</em>Array</code>;
<li>function types ((&sigma;, &hellip;) &rarr; &tau;) &and; &hellip; &and; ((&sigma;&prime;, &hellip;) &rarr; &tau;&prime;);
<li>function table types ((&sigma;, &hellip;) &rarr; &tau;)[<em>n</em>]; and
<li>the FFI function type <code>Function</code>.
</ul>

<p>The "&and;" notation for function types serves to represent
overloaded functions and operators. For example,
the <a href="#standard-library"><code>Math.abs</code> function</a> is
overloaded to accept either integers or floating-point numbers, and
returns a different type in each case. Similarly, many of
the <a href="#operators">operators</a> have overloaded types.

<p>The meta-variable &gamma; is used to stand for global types.

<h2>Environments</h2>

<p>Validating an asm.js module depends on tracking contextual
information about the set of definitions and variables in scope. This
section defines the <dfn>environments</dfn> used by the validation
logic.

<h3>Global Environment</h3>

<p>An asm.js module is validated in the context of a <dfn>global
environment</dfn>. The global environment maps each global variable to
its type as well as indicating whether the variable is mutable:

<p><div>{ <em>x</em> : <span class="meta">(</span><tt>mut<span class="meta">|</span>imm</tt><span class="meta">)</span> &gamma;, &hellip; }</div>

<p>The meta-variable &Delta; is used to stand for a global environment.

<h3>Variable Environment</h3>

<p>In addition to the <span>global environment</span>, each function
body in an asm.js module is validated in the context of
a <dfn>variable environment</dfn>. The variable environment maps each
function parameter and local variable to its value type:

<p>{ <em>x</em> : &tau;, &hellip; }

<p>The meta-variable &Gamma; is used to stand for a variable environment.

<h3>Environment Lookup</h3>

<p>Looking up a variable's type

<div class="example">
<em>Lookup</em>(&Delta;, &Gamma;, <em>x</em>)
</div>

<p>is defined by:

<ul>
<li>&tau; if <em>x</em> : &tau; occurs in &Gamma;;
<li>&gamma; if <em>x</em> does not occur in &Gamma; and <em>x</em>
: <code>mut</code> &gamma; or <em>x</em> : <code>imm</code> &gamma;
occurs in &Delta;
</ul>

<p>If <em>x</em> does not occur in either environment then
the <em>Lookup</em> function has no result.

<h2>Syntax</h2>

<p>Validation of an asm.js module is specified by reference to
the <a href="http://ecma-international.org/ecma-262/5.1/#sec-A">ECMAScript
grammar</a>, but conceptually operates at the level of abstract
syntax. In particular, an asm.js validator must obey the following
rules:

<ul>
<li>Empty statements (<code>;</code>) are always ignored, whether in
the top level of a module or inside an asm.js function body.
<li>No variables bound anywhere in an asm.js module (whether in the
module function parameter list, global variable declarations, asm.js
function names, asm.js function parameters, or local variable
declarations) may have the name <code>eval</code>
or <code>arguments</code>.
<li>Where it would otherwise parse equivalently in JavaScript,
parentheses are meaningless. Even where the specification matches on
specific productions of <em>Expression</em> such as literals, the
source may contain extra meaningless parentheses without affecting
validation.
<li>Automatic semicolon insertion is respected. An asm.js source file
may omit semicolons wherever JavaScript allows them to be ommitted.
</ul>

<p>These rules are otherwise left implicit in the rest of the
specification.

<h2>Annotations</h2>

<p>All variables in asm.js are explicitly annotated with type
information so that their type can be statically enforced by
validation.

<h3>Parameter Type Annotations</h3>

<p>Every parameter in an asm.js function is provided with an explicit
type annotation in the form of a coercion. This coercion serves two
purposes: the first is to make the parameter type statically apparent
for validation; the second is to ensure that if the function is
exported, the arguments dynamically provided by external JavaScript
callers are coerced to the expected type. For example, a bitwise OR
coercion annotates a parameter as having type <code>int</code>:

<div class="example">
<pre>function add1(x) {
    x = x|0; // x : int
    return (x+1)|0;
}</pre>
</div>

<p>In an AOT implementation, the body of the function can be
implemented fully optimized, and the function can be given two entry
points: an internal entry point for asm.js callers, which are
statically known to provide the proper type, and an external dynamic
entry point for JavaScript callers, which must perform the full
coercions (which might involve arbitrary JavaScript computation, e.g.,
via implicit calls to <code>valueOf</code>).

<p>There are two recognized parameter type annotations:

<div class="example">
<em>x:Identifier</em> <code>=</code> <em>x:Identifier</em><code>|0;</code><br>
<em>x:Identifier</em> <code>=</code> <code>+</code><em>x:Identifier</em><code>;</code>
</div>

<p>The first form annotates a parameter as type <code>int</code>, and
the second as type <code>double</code>.

<h3>Return Type Annotations</h3>

<p>An asm.js function's <em>formal return type</em> is determined by
the last statement in the function body, which for
non-<code>void</code> functions is required to be
a <em>ReturnStatement</em>. This distinguished return statement may
take one of four forms:

<div class="example">
<code>return +</code><em>e:Expression</em><code>;</code><br>
<code>return </code><em>e:Expression</em><code>|0;</code><br>
<code>return </code><em>n:</em><code>-</code><span class="meta opt">?</span><em>NumericLiteral</em></em><code>;</code><br>
<code>return;</code>
</div>

<p>The first form has return type <code>double</code>. The second has
type <code>signed</code>. The third has return
type <code>double</code> if <em>n</em> is composed of a floating-point
literal, i.e., a numeric literal with the character <code>.</code> in
its source; alternatively, if <em>n</em> is composed of an integer
literal and has its value in the range [-2<sup>31</sup>,
2<sup>31</sup>), the return statement has return
type <code>signed</code>. The fourth form has return
type <code>void</code>.

<p>If the last statement in the function body is not
a <em>ReturnStatement</em>, or if the function body has no non-empty
statements (other than the initial declarations and
coercions&mdash;see <a href="#function-declarations">Function
Declarations</a>), the function's return type is <code>void</code>.

<h3>Function Type Annotations</h3>

<p>The type of a function declaration

<div class="example">
<code>function</code> <em>f:Identifier</em><code>(</code><em>x:Identifier</em>&hellip;<code>) {</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;</code><span class="meta">(</span><em>x:Identifier</em> <code>=</code> <em>AssignmentExpression</em><code>;</code><span class="meta">)</span>&hellip;<br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;</code><span class="meta">(</span><code>var </code><span class="meta">(</span><em>y:Identifier</em> <code>=</code> <em>n:</em><code>-</code><span class="meta opt">?</span><em>NumericLiteral</em><span class="meta">)</span><code>,</code>&hellip;<span class="meta">)</span>&hellip;<br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;</code><em>body:Statement</em>&hellip;<br>
<code>}</code>
</div>

<p>is (&sigma;,&hellip;) &rarr; &tau; where &sigma;,&hellip; are the
types of the parameters, as provided by
the <a href="#parameter-type-annotations">parameter type
annotations</a>, and &tau; is the formal return type, as provided by
the <a href="#return-type-annotations">return type annotation</a>. The
variable <em>f</em> is stored in
the <a href="#global-environment">global environment</a> with
type <code>imm</code> (&sigma;,&hellip;) &rarr; &tau;.

<h3>Variable Type Annotations</h3>

<p>The types of variable declarations are determined by their
initializer. A variable initializer may be a floating-point literal,
which is any numeric literal with the character <code>.</code> in
their source, and has type <code>double</code>. Alternatively, an
initializer may be an integer literal in the range [-2<sup>31</sup>,
2<sup>32</sup>), which has type <code>int</code>.

<h3>Global Variable Type Annotations</h3>

<p>A global variable declaration is a <em>VariableStatement</em> node
in one of several allowed forms.

<p>A global program variable is initialized to a literal:

<div class="example">
<code>var</code> <em>x:Identifier</em> <code>=</code> <em>n:</em><code>-</code><span class="meta opt">?</span><em>NumericLiteral</em><code>;</code>
</div>

<p>The global variable <em>x</em> is stored in
the <a href="#global-environment">global environment</a> with
type <code>mut</code> &tau;, where &tau; is determined in the same way
as local <a href="#variable-type-annotations">variable type
annotations</a>.

<p>A standard library import is of one of the following two forms:

<div class="example">
<code>var</code> <em>x:Identifier</em> <code>=</code> <em>stdlib:Identifier</em><code>.</code><em>y:Identifier</em><code>;</code><br>
<code>var</code> <em>x:Identifier</em> <code>=</code> <em>stdlib:Identifier</em><code>.Math.</code><em>y:Identifier</em><code>;</code>
</div>

<p>The variable <em>stdlib</em> must match the first parameter of
the <a href="#modules">module declaration</a>. The global
variable <em>x</em> is stored in
the <a href="#global-environment">global environment</a> with
type <code>imm</code> &gamma;, where &gamma; is the type of
library <em>y</em> or <code>Math.</code><em>y</em> as specified by
the <a href="#standard-library">standard library types</a>.

<p>A foreign import is of one of the following three forms:

<div class="example">
<code>var</code> <em>x:Identifier</em> <code>=</code> <em>foreign:Identifier</em><code>.</code><em>y:Identifier</em><code>;</code><br>
<code>var</code> <em>x:Identifier</em> <code>=</code> <em>foreign:Identifier</em><code>.</code><em>y:Identifier</em><code>|0;</code><br>
<code>var</code> <em>x:Identifier</em> <code>=</code> <code>+</code><em>foreign:Identifier</em><code>.</code><em>y:Identifier</em><code>;</code>
</div>

<p>The variable <em>foreign</em> must match the second parameter of
the <a href="#modules">module declaration</a>. The global
variable <em>x</em> is stored in
the <a href="#global-environment">global environment</a> with
type <code>imm Function</code> for the first form, <code>imm
int</code> for the second, and <code>imm double</code> for the third.

<p>A global heap view is of the following form:

<div class="example">
<code>var</code> <em>x:Identifier</em> <code>= new</code> <em>stdlib:Identifier</em><code>.</code><em>view:Identifier</em><code>(</code><em>heap:Identifier</em><code>);</code>
</div>

<p>The variable <em>stdlib</em> must match the first parameter of
the <a href="#modules">module declaration</a> and the
variable <em>heap</em> must match the third. The
identifier <em>view</em> must be one of the
standard <a href="https://developer.mozilla.org/en-US/docs/JavaScript/Typed_arrays/ArrayBufferView"><code>ArrayBufferView</code></a>
type names. The global variable <em>x</em> is stored in
the <a href="#global-environment">global environment</a> with
type <code>imm</code>
<em>view</em>.

<h3>Function Table Types</h3>

<p>A function table is a <em>VariableStatement</em> of the form:

<div class="example">
<code>var</code> <em>x:Identifier</em><code> = [</code><em>f:Identifier</em><code>,</code>&hellip;<code>];</code>
</div>

<p>The length of the array literal must be a power of two and all the
identifiers <em>f</em> must map to the same type <code>imm</code>
(&sigma;,&hellip;) &rarr; &tau; in
the <a href="#global-environment">global environment</a>. The function
table <em>x</em> is stored in the global environment with
type <code>imm</code> ((&sigma;,&hellip;) &rarr; &tau;)[<em>n</em>]
where <em>n</em> is the length of the array literal.

<h2>Validation Rules</h2>

<p>To ensure that a JavaScript function is a proper asm.js module, it
must first be statically validated. This section specifies the
validation rules. The rules operate on JavaScript abstract syntax,
i.e., the output of a JavaScript parser. The non-terminals refer to
parse nodes defined by productions in
the <a href="http://ecma-international.org/ecma-262/5.1/#sec-A">ECMAScript
grammar</a>, but note that the asm.js validator only accepts a subset
of legal JavaScript programs.

<h3>Modules</h3>

<p>An asm.js module is a <em>FunctionDeclaration</em>
or <em>FunctionExpression</em> node with the following form:

<!--
<div class="example">
<code>function</code> <em>Identifier<sub>opt</sub></em><code>() { "use asm";</code> <em>decl:SourceElement</em>&hellip; <em>ReturnStatement</em> <code>}</code><br>
<code>function</code> <em>Identifier<sub>opt</sub></em><code>(</code><em>stdlib:Identifier</em><code>) { "use asm";</code> <em>decl:SourceElement</em>&hellip; <em>ReturnStatement</em> <code>}</code><br>
<code>function</code> <em>Identifier<sub>opt</sub></em><code>(</code><em>stdlib:Identifier</em><code>,</code> <em>foreign:Identifier</em><code>) { "use asm";</code> <em>decl:SourceElement</em>&hellip; <em>ReturnStatement</em> <code>}</code><br>
</div>
-->

<div class="example">
<code>function</code> <em>f:Identifier<sub>opt</sub></em><code>(</code><span class="meta">(</span><em>stdlib:Identifier</em><code><span class="meta">(</span>,</code> <em>foreign:Identifier</em><span class="meta">(</span><code>,</code> <em>heap:Identifier</em><span class="meta">)</span><sub><em>opt</em></sub><span class="meta">)</span><sub><em>opt</em></sub><span class="meta">)</span><sub><em>opt</em></sub><code>) {<br>
&nbsp;&nbsp;&nbsp;&nbsp;"use asm";</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;</code><em>var:VariableStatement</em>&hellip;<br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;</code><em>fun:FunctionDeclaration</em>&hellip;<br>
<!--
<code>&nbsp;&nbsp;&nbsp;&nbsp;</code><span class="meta">(</span><em>var:VariableStatement</em> <span class="meta">|</span> <em>fun:FunctionDeclaration</em><span class="meta">)</span>&hellip;<br>
-->
<code>&nbsp;&nbsp;&nbsp;&nbsp;</code><em>table:VariableStatement</em>&hellip;<br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;</code><em>exports:ReturnStatement</em><br>
<code>}</code>
</div>

<p>A module is valid if:

<ul>
<li><em>f</em>, <em>stdlib</em>, <em>foreign</em>, <em>heap</em>, and
the <em>var</em>, <em>fun</em>, and <em>table</em> variables are all
mutually distinct;
<li>the global environment &Delta; is constructed in two stages:
  <ol>
  <li>the types from
  the <a href="#global-variable-type-annotations">global variable type
  annotations</a> in the <em>var</em> declarations and
  the <a href="#function-type-annotations">function type
  annotations</a> in the <em>fun</em> declarations are the initial
  contents of &Delta;;
  <li>the types of the <a href="#function-table-types">function
  tables</a> in the <em>table</em> declarations</a> are extracted
  using the initial contents of &Delta;, and their types are added to
  &Delta;.
  </ol>
<li>each <em>fun</em> declaration is valid in &Delta;;
<li>each <em>table</em> declaration is valid in &Delta;;
<li>and <em>exports</em> is valid in &Delta;.
</ul>

<h3>Export Declarations</h3>

<p>An asm.js module's export declaration is a <em>ReturnStatement</em>
returning either a single asm.js function or an object literal
exporting multiple asm.js functions.

<p>An export declaration node

<div class="example">
<code>return</code> <code>{</code> <span class="meta">(</span><em>x:Identifier</em> <code>:</code> <em>f:Identifier</em><span class="meta">)</span><code>,</code>&hellip; <code> };</code>
</div>

<p>is valid if for each <em>f</em>, &Delta;(f) = <code>imm</code>
&gamma; where &gamma; is a function type (&sigma;,&hellip;) &rarr;
&tau;.

<p>An export declaration node

<div class="example">
<code>return</code> <em>f:Identifier</em><code>;</code>
</div>

<p>is valid if &Delta;(f) = <code>imm</code> &gamma; where &gamma; is
a function type (&sigma;,&hellip;) &rarr; &tau;.

<h3>Function Declarations</h3>

<!--
<div class="example">
<em>SourceElement</em> : <code>function</code> <em>Identifier</em><code>(</code><span class="seq"><em>x</em></span><code>) {</code> <span class="seq"><em>x</em> <code>=</code> <em>AsmAnnotation<sub>x</sub></em><code>;</code></span> <em>AsmFunctionBody</em> <code>}</code>
</div>

<div class="example">
<em>SourceElement</em> : <code>function</code> <em>Identifier</em><code>(</code><em>FormalParameterList<sub>opt</sub></em><code>) {</code> <em>AsmAnnotationList<sub>opt</sub></em> <em>List</em>&lt;<em>VariableStatement</em>&gt; <em>List</em>&lt;<em>Statement</em>&gt; <code>}</code>
</div>
-->

<p>An asm.js function declaration is a <em>FunctionDeclaration</em> node

<div class="example">
<code>function</code> <em>f:Identifier</em><code>(</code><em>x:Identifier</em><code>,</code>&hellip;<code>) {</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;</code><span class="meta">(</span><em>x:Identifier</em> <code>=</code> <em>AssignmentExpression</em><code>;</code><span class="meta">)</span>&hellip;<br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;</code><span class="meta">(</span><code>var </code><span class="meta">(</span><em>y:Identifier</em> <code>=</code> <em>n:</em><code>-</code><span class="meta opt">?</span><em>NumericLiteral</em><span class="meta">)</span><code>,</code>&hellip;<code>;</code><span class="meta">)</span>&hellip;<br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;</code><em>body:Statement</em>&hellip;<br>
<code>}</code>
</div>

<p>A function declaration is valid if:

<ul>
<li>&Delta;(f) = <code>imm</code> (&sigma;,&hellip;) &rarr; &tau;;
<li>the <em>x</em> and <em>y</em> variables are all mutually distinct;
<li>the variable environment &Gamma; is constructed by mapping each
parameter <em>x</em> to
its <a href="#parameter-type-annotations">parameter type
annotation</a> and each local variable <em>y</em> to
its <a href="#variable-type-annotations">variable type annotation</a>;
<li>each <code>body</code> statement is valid in &Delta; and &Gamma;
with expected return type &tau;.
</ul>

<h3>Statements</h3>

<p>Each statement is validated in the context of a <span>global
environment</span> &Delta;, a <span>variable environment</span>
&Gamma;, and an expected return type &tau;. Unless otherwise
explicitly stated, a recursive validation of a subterm uses the same
context as its containing term.

<h4>Block</h4>

<p>A <em>Block</em> statement node

<div class="example">
<code>{</code> <em>stmt:Statement</em>&hellip; <code>}</code>
</div>

<p>is valid if each <em>stmt</em> is valid.

<h4>ExpressionStatement</h4>

<p>An <em>ExpressionStatement</em> node

<div class="example">
<em>cexpr:CallExpression</em> <code>;</code>
</div>

<p>is valid if <em>cexpr</em> is valid with actual return
type <code>void</code>.

<p>An <em>ExpressionStatement</em> node

<div class="example">
<em>expr:Expression</em> <code>;</code>
</div>

<p>is valid if <em>expr</em> validates as some type &sigma;.

<h4>EmptyStatement</h3>

<p>An <em>EmptyStatement</em> node is always valid.

<h4>IfStatement</h4>

<p>An <em>IfStatement</em> node

<div class="example">
<code>if (</code> <em>expr:Expression</em> <code>)</code> <em>stmt1:Statement</em> <code>else</code> <em>stmt2:Statement</em>
</div>

<p>is valid if <em>expr</em> validates as a subtype
of <code>int</code> and <em>stmt1</em> and <em>stmt2</em> are both
valid.

<p>An <em>IfStatement</em> node

<div class="example">
<code>if (</code> <em>expr:Expression</em> <code>)</code> <em>stmt:Statement</em>
</div>

<p>is valid if <em>expr</em> validates as a subtype
of <code>int</code> and <em>stmt</em> is valid.

<h4>ReturnStatement</h4>

<p>A <em>ReturnStatement</em> node

<div class="example">
<code>return</code> <em>expr:Expression</em> <code>;</code>
</div>

<p>is valid if <em>expr</em> validates as a subtype of the expected
return type &tau;.

<p>A <em>ReturnStatement</em> node

<div class="example">
<code>return ;</code>
</div>

<p>is valid if the expected return type &tau; is <code>void</code>.


<h4>IterationStatement</h4>

<p>An <em>IterationStatement</em> node

<div class="example">
<code>while (</code> <em>expr:Expression</em> <code>)</code> <em>stmt:Statement</em>
</div>

<p>is valid if <em>expr</em> validates as a subtype
of <code>int</code> and <em>stmt</em> is valid.

<p>An <em>IterationStatement</em> node

<div class="example">
<code>do</code> <em>stmt:Statement</em> <code>while (</code> <em>expr:Expression</em> <code>) ;</code>
</div>

<p>is valid if <em>stmt</em> is valid and <em>expr</em> validates as a
subtype of <code>int</code>.

<p>An <em>IterationStatement</em> node

<div class="example">
<code>for (</code> <em>init:ExpressionNoIn<sub>opt</sub></em> <code>;</code> <em>test:Expression<sub>opt</sub></em> <code>;</code> <em>update:Expression<sub>opt</sub></em> <code>)</code> <em>body:Statement</em>
</div>

<p>is valid if <em>init</em> validates (if present),
<em>test</em> validates as a subtype of <code>int</code> (if
present), <em>update</em> validates (if present), and <em>body</em> is
valid.

<h4>BreakStatement</h4>

<p>A <em>BreakStatement</em> node

<div class="example">
<code>break</code> <em>Identifier<sub>opt</sub></em> <code>;</code>
</div>

<p>is always valid.

<h4>ContinueStatement</h4>

<p>A <em>ContinueStatement</em> node

<div class="example">
<code>continue</code> <em>Identifier<sub>opt</sub></em> <code>;</code>
</div>

<p>is always valid.

<h4>LabelledStatement</h4>

<p>A <em>LabelledStatement</em> node

<div class="example">
<em>Identifier</em> <code>:</code> <em>body:Statement</em>
</div>

<p>is valid if <em>body</em> is valid.

<h4>SwitchStatement</h4>

<p>A <em>SwitchStatement</em> node

<div class="example">
<code>switch (</code> <em>test:Expression</em> <code>)</code> <code>{</code> <em>case:CaseClause</em>&hellip; <em>default:DefaultClause<sub>opt</sub></em> <code>}</code>
</div>

<p>is valid if

<ul>
<li><em>test</em> validates as a subtype of <code>signed</code>;
<li>each <em>case</em> validates with expected case type <code>signed</code>;
<li>each <em>case</em> value is distinct;
<li>the difference between the maximum and minimum <em>case</em> values is less than 2<sup>31</sup>;
<li><em>default</em> is valid.
</ul>

<!--
<div class="compilation">
<p>
A <code>switch</code> statement in asm.js is intended to be compiled
unconditionally (i.e., regardless of its contents) to
a <a href="http://en.wikipedia.org/wiki/Branch_table">jump
table</a>. Branch instructions can instead be expressed
via <code>if</code> statements.
</p>

<p>
Note that a <code>switch</code> statement with a sparse set
of <code>case</code> values can result in a large jump
table. Programmers and code generators are therefore expected to be
responsible for breaking up sparse value sets into
multiple <code>switch</code> statements separated
by <code>if</code>-guards if they wish to reduce the size of jump
tables.
</p>
</div>
-->

<!--
<h3>Statement Lists</h3>

<p>Just like statements, statement lists are validated in the context
of a <span>global environment</span> &Delta;, a <span>variable
environment</span> &Gamma;, and an expected return type &tau;. Unless
otherwise explicitly stated, a recursive validation of a subterm uses
the same context as its containing term.

<p>A <em>StatementList</em>

<div class="example">
<em>StatementList</em> : <em>StatementList<sub>opt</sub></em> <em>Statement</em>
</div>

<p>is valid if the <em>StatementList</em> (if any) is valid and the <em>Statement</em> is valid.
-->


<h3>Switch Cases</h3>

<p>Cases in a <code>switch</code> block are validated in the context
of a <span>global environment</span> &Delta;, a <span>variable
environment</span> &Gamma;, an expected return type &tau;, and an
expected case type &sigma;. Unless otherwise explicitly stated, a
recursive validation of a subterm uses the same context as its
containing term.

<!--
<h4>CaseBlock</h4>

<p>A <em>CaseBlock</em> node

<div class="example">
<code>{</code> <em>CaseClause</em>&hellip; <em>DefaultClause<sub>opt</sub></em> <code>}</code>
</div>

<p>is valid if the <em>CaseClause</em> list is valid and the <em>DefaultClause</em> (if any) is valid.
-->

<!--
<h4>CaseClauses</h4>

<p>A <em>CaseClauses</em> list

<div class="example">
<em>CaseClauses</em> : <em>CaseClauses<sub>opt</sub></em> <em>CaseClause</em>
</div>

<p>is valid if the <em>CaseClauses</em> (if any) are valid and the <em>CaseClause</em> is valid.
-->

<h4>CaseClause</h4>

<p>A <em>CaseClause</em> node

<div class="example">
<code>case</code> <em>n:</em><code>-</code><span class="meta opt">?</span><em>NumericLiteral</em> <code>:</code> <em>stmt:Statement</em>&hellip;
</div>

<p>is valid if

<ul>
<li>the source of <em>n</em> does not contain a <code>.</code> character;
<li><em>n</em> is in the range [-2<sup>31</sup>, 2<sup>31</sup>);
<li>each <em>stmt</em> is valid.
</ul>

<h4>DefaultClause</h4>

<p>A <em>DefaultClause</em> node

<div class="example">
<code>default :</code> <em>stmt:Statement</em>&hellip;
</div>

<p>is valid if each <em>stmt</em> is valid.


<h3>Expressions</h3>

<p>Each expression is validated in the context of a <span>global
environment</span> &Delta; and a <span>variable environment</span>
&Gamma;, and validation determines the type of the expression. Unless
otherwise explicitly stated, a recursive validation of a subterm uses
the same context as its containing term.

<h4>Expression</h4>

<p>An <em>Expression</em> node:

<div class="example">
<em>expr1:AssignmentExpression</em> <code>,</code> &hellip; <code>,</code> <em>exprn:AssignmentExpression</em>
</div>

<p>validates as type &tau; if for every <em>i</em>
&lt; <em>n</em>, one of the following conditions holds:

<ul>
<li><em>expri</em> is a <em>CallExpression</em> and is valid with
actual return type <code>void</code>; or
<li><em>expri</em> validates as some type &sigma;
</ul>

<p>and <em>exprn</em> validates as type &tau;.

<h4>NumericLiteral</h4>

<p>For a <em>NumericLiteral</em> node:

<ul>
<li>if the source contains a <code>.</code> character, the expression
validates as type <code>double</code>;
<li>if the source does not contain a <code>.</code> character and its
numeric value is in the range [0, 2<sup>31</sup>), the expression
validates as type <code>fixnum</code>;
<li>if the source does not contain a <code>.</code> character and its
numeric value is in the range [2<sup>31</sup>, 2<sup>32</sup>), the
expression validates as type <code>unsigned</code>.
</ul>

<p>Note that the case of negative integer constants is handled
under <a href="#unaryexpression"><em>UnaryExpression</em></a>.

<p>Note that integer literals outside the range [0, 2<sup>32</sup>)
are invalid, i.e., fail to validate.

<h4>Identifier</h4>

<p>An <em>Identifier</em> node

<div class="example">
<em>x:Identifier</em>
</div>

<p>validates as <em>Lookup</em>(&Delta;, &Gamma;, <em>x</em>).

<h4>MemberExpression</h4>

<p>A <em>MemberExpression</em> node

<div class="example">
<em>x:Identifier</em><code>[</code><em>n:</em><code>-</code><span class="meta opt">?</span><em>NumericLiteral</em><code>]</code>
</div>

<p>validates at type &tau; if:

<ul>
<li><em>Lookup</em>(&Delta;, &Gamma;, <em>x</em>) = <em>view</em>
where <em>view</em> is
an <a href="https://developer.mozilla.org/en-US/docs/JavaScript/Typed_arrays/ArrayBufferView"><code>ArrayBufferView</code></a>
type;
<li>the element type of <em>view</em> is &tau;;
<li>the source of <em>n</em> does not contain a <code>.</code> character;
<li>0 &leq; <em>n</em> &lt; 2<sup>32</sup>.
</ul>

<p>A <em>MemberExpression</em> node

<div class="example">
<em>x:Identifier</em><code>[</code><em>expr:Expression</em><code>]</code>
</div>

<p>validates at type <code>intish</code> if:

<ul>
<li><em>Lookup</em>(&Delta;, &Gamma;, <em>x</em>) = <em>view</em> where <em>view</em> is
an <a href="https://developer.mozilla.org/en-US/docs/JavaScript/Typed_arrays/ArrayBufferView"><code>ArrayBufferView</code></a>
type;
<li>the element size of <em>view</em> is 1;
<li>the element type of <em>view</em> is <code>intish</code>;
<li><em>expr</em> validates as type <code>int</code>.
</ul>

<p>A <em>MemberExpression</em> node

<div class="example">
<em>x:Identifier</em><code>[</code><em>expr:Expression</em> <code>&gt;&gt;</code> <em>n:</em><code>-</code><span class="meta opt">?</span><em>NumericLiteral</em><code>]</code>
</div>

<p>validates at type &tau; if:

<ul>
<li><em>Lookup</em>(&Delta;, &Gamma;, <em>x</em>) = <em>view</em> where <em>view</em> is
an <a href="https://developer.mozilla.org/en-US/docs/JavaScript/Typed_arrays/ArrayBufferView"><code>ArrayBufferView</code></a>
type;
<li>the element size of <em>view</em> is <em>bytes</em>;
<li>the element type of <em>view</em> is &tau;;
<li><em>expr</em> validates as type <code>intish</code>;
<li>the source of <em>n</em> does not contain a <code>.</code> character;
<li><em>n</em> = log<sub>2</sub>(<em>bytes</em>).
</ul>

<!--
<div class="compilation">
<p><em>TODO: explain compilation model of heap access</em></p>
</div>
-->

<h4>AssignmentExpression</h4>

<p>An <em>AssignmentExpression</em> node

<div class="example">
<em>x:Identifier</em> <code>=</code> <em>expr:AssignmentExpression</em>
</div>

<p>validates as type &tau; if the nested <em>AssignmentExpression</em>
validates as type &tau; and one of the following two conditions holds:

<ul>
<li><em>x</em> is bound in &Gamma; as a supertype of &tau;; or
<li><em>x</em> is not bound in &Gamma; and is bound to a mutable supertype of &tau; in &Delta;.
</ul>

<p>An <em>AssignmentExpression</em> node

<div class="example">
<em>lhs:MemberExpression</em> <code>=</code> <em>rhs:AssignmentExpression</em>
</div>

<p>validates as type &tau; if <em>lhs</em> validates as type
&tau;, <em>rhs</em> validates as type &sigma;, and &sigma; is a
subtype of &tau;.

<!--
<div class="example">
<em>x:Identifier</em><code>[</code><em>n:NumericLiteral</em><code>] = </code><em>rhs:AssignmentExpression</em><br>
<em>x:Identifier</em><code>[</code><em>expr:Expression</em><code>] = </code><em>rhs:AssignmentExpression</em><br>
<em>x:Identifier</em><code>[</code><em>expr:Expression</em> <code>&gt;&gt;</code> <em>n:NumericLiteral</em><code>] = </code><em>rhs:AssignmentExpression</em><br>
</div>
-->

<h4>UnaryExpression</h4>

<p>A <em>UnaryExpression</em> node of the form

<div class="example">
<code>-</code><em>NumericLiteral</em>
</div>

<p>validates as type <code>signed</code> if
the <em>NumericLiteral</em> source does not contain a <code>.</code>
character and the numeric value of the expression is in the range
[-2<sup>31</sup>, 0).

<p>A <em>UnaryExpression</em> node of the form

<div class="example">
<code>+</code><em>cexpr:CallExpression</em>
</div>

<p>validates as type <code>double</code> if <em>cexpr</em> is valid
with actual return type <code>double</code>.

<p>A <em>UnaryExpression</em> node of the form

<div class="example">
<em>op:</em><span class="meta">(</span><code>+</code><span class="meta">|</span><code>-</code><span class="meta">|</span><code>~</code><span class="meta">|</span><code>!</code><span class="meta">)</span><em>arg:UnaryExpression</em>
</div>

<p>validates as type &tau; if the type of <em>op</em> is &hellip;
&and; (&sigma;) &rarr; &tau; &and; &hellip; and <em>arg</em> validates
as a subtype of &sigma;.

<p>A <em>UnaryExpression</em> node of the form

<div class="example">
<code>~~</code><em>arg:UnaryExpression</em>
</div>

<p>validates as type <code>signed</code> if <em>arg</em> validates as
a subtype of <code>double</code>.

<h4>MultiplicativeExpression</h4>

<p>A <em>MultiplicativeExpression</em> node

<div class="example">
<em>lhs:MultiplicativeExpression</em> <em>op:</em><span class="meta">(</span><code>*</code><span class="meta">|</span><code>/</code><span class="meta">|</span><code>%</code><span class="meta">)</span> <em>rhs:UnaryExpression</em>
</div>

<p>validates as type &tau; if the type of <em>op</em> is &hellip;
&and; (&sigma;<sub>1</sub>, &sigma;<sub>2</sub>) &rarr; &tau; &and;
&hellip; and <em>lhs</em> validates as a subtype of
&sigma;<sub>1</sub> and <em>rhs</em> validates as a subtype of
&sigma;<sub>2</sub>.

<p>A <em>MultiplicativeExpression</em> node

<div class="example">
<em>expr:MultiplicativeExpression</em> <code>*</code> <em>n:</em><code>-</code><span class="meta opt">?</span><em>NumericLiteral</em><br>
<em>n:</em><code>-</code><span class="meta opt">?</span><em>NumericLiteral</em> <code>*</code> <em>expr:UnaryExpression</em>
</div>

<p>validates as type <code>intish</code> if the source of <em>n</em>
does not contain a <code>.</code> character and -2<sup>20</sup>
&lt; <em>n</em> &lt; 2<sup>20</sup> and <em>expr</em> validates as a
subtype of <code>int</code>.

<h4>AdditiveExpression</h4>

<p>An <em>AdditiveExpression</em> node

<div class="example">
<em>expr<sub>1</sub></em> <span class="meta">(</span><code>+</code><span class="meta">|</span><code>-</code><span class="meta">)</span> &hellip; <span class="meta">(</span><code>+</code><span class="meta">|</span><code>-</code><span class="meta">)</span> <em>expr<sub>n</sub></em>
</div>

<p>validates as type <code>intish</code> if:

<ul>
<li>each <em>expr<sub>i</sub></em> validates as type <code>int</code>;
<li><em>n</em> &leq; 2<sup>20</sup>.
</ul>

<p>Otherwise, an <em>AdditiveExpression</em> node

<div class="example">
<em>lhs:AdditiveExpression</em> <em>op:</em><span class="meta">(</span><code>+</code><span class="meta">|</span><code>-</code><span class="meta">)</span> <em>rhs:MultiplicativeExpression</em>
</div>

<p>validates as type <code>double</code> if the type of <em>op</em> is
(&sigma;<sub>1</sub>, &sigma;<sub>2</sub>) &rarr; <code>double</code>
and <em>lhs</em> validates as a subtype of &sigma;<sub>1</sub>
and <em>rhs</em> validates as a subtype of &sigma;<sub>2</sub>.

<h4>ShiftExpression</h4>

<p>A <em>ShiftExpression</em> node

<div class="example">
<em>lhs:ShiftExpression</em> <em>op:</em><span class="meta">(</span><code>&lt;&lt;</code><span class="meta">|</span><code>&gt;&gt;</code><span class="meta">|</span><code>&gt;&gt;&gt;</code><span class="meta">)</span> <em>rhs:AdditiveExpression</em>
<!--
<em>lhs:ShiftExpression</em> <code>&lt;&lt;</code> <em>rhs:AdditiveExpression</em><br>
<em>lhs:ShiftExpression</em> <code>&gt;&gt;</code> <em>rhs:AdditiveExpression</em><br>
<em>lhs:ShiftExpression</em> <code>&gt;&gt;&gt;</code> <em>rhs:AdditiveExpression</em><br>
-->
</div>

<p>validates as type &tau; if the type of <em>op</em> is &hellip;
&and; (&sigma;<sub>1</sub>, &sigma;<sub>2</sub>) &rarr; &tau; &and;
&hellip; and <em>lhs</em> validates as a subtype of
&sigma;<sub>1</sub> and <em>rhs</em> validates as a subtype of
&sigma;<sub>2</sub>.

<h4>RelationalExpression</h4>

<p>A <em>RelationalExpression</em> node

<div class="example">
<em>lhs:RelationalExpression</em> <em>op:</em><span class="meta">(</span><code>&lt;</code><span class="meta">|</span><code>&gt;</code><span class="meta">|</span><code>&lt;=</code><span class="meta">|</span><code>&gt;=</code><span class="meta">)</span> <em>rhs:ShiftExpression</em>
<!--
<em>lhs:RelationalExpression</em> <code>&lt;</code> <em>rhs:ShiftExpression</em><br>
<em>lhs:RelationalExpression</em> <code>&gt;</code> <em>rhs:ShiftExpression</em><br>
<em>lhs:RelationalExpression</em> <code>&lt;=</code> <em>rhs:ShiftExpression</em><br>
<em>lhs:RelationalExpression</em> <code>&gt;=</code> <em>rhs:ShiftExpression</em><br>
-->
</div>

<p>validates as type &tau; if the type of <em>op</em> is &hellip;
&and; (&sigma;<sub>1</sub>, &sigma;<sub>2</sub>) &rarr; &tau; &and;
&hellip; and <em>lhs</em> validates as a subtype of
&sigma;<sub>1</sub> and <em>rhs</em> validates as a subtype of
&sigma;<sub>2</sub>.

<h4>EqualityExpression</h4>

<p>An <em>EqualityExpression</em> node

<div class="example">
<em>lhs:EqualityExpression</em> <em>op:</em><span class="meta">(</span><code>==</code><span class="meta">|</span><code>!=</code><span class="meta">)</span> <em>rhs:RelationalExpression</em>
<!--
<em>lhs:EqualityExpression</em> <code>==</code> <em>rhs:RelationalExpression</em><br>
<em>lhs:EqualityExpression</em> <code>!=</code> <em>rhs:RelationalExpression</em>
-->
</div>

<p>validates as type &tau; if the type of <em>op</em> is &hellip;
&and; (&sigma;<sub>1</sub>, &sigma;<sub>2</sub>) &rarr; &tau; &and;
&hellip; and <em>lhs</em> validates as a subtype of
&sigma;<sub>1</sub> and <em>rhs</em> validates as a subtype of
&sigma;<sub>2</sub>.

<h4>BitwiseANDExpression</h4>

<p>A <em>BitwiseANDExpression</em> node

<div class="example">
<em>lhs:BitwiseANDExpression</em> <code>&amp;</code> <em>rhs:EqualityExpression</em><br>
</div>

<p>validates as type <code>signed</code> if <em>lhs</em>
and <em>rhs</em> validate as type <code>intish</code>.

<h4>BitwiseXORExpression</h4>

<p>A <em>BitwiseXORExpression</em> node

<div class="example">
<em>lhs:BitwiseXORExpression</em> <code>^</code> <em>rhs:BitwiseANDExpression</em><br>
</div>

<p>validates as type <code>signed</code> if <em>lhs</em>
and <em>rhs</em> validate as type <code>intish</code>.

<h4>BitwiseORExpression</h4>

<p>A <em>BitwiseORExpression</em> node

<div class="example">
<em>cexpr:CallExpression</em> <code>|0</code><br>
</div>

<p>validates as type <code>signed</code> if <em>cexpr</em> is valid
with actual return type <code>signed</code>.

<p>A <em>BitwiseORExpression</em> node

<div class="example">
<em>lhs:BitwiseORExpression</em> <code>|</code> <em>rhs:BitwiseXORExpression</em><br>
</div>

<p>validates as type <code>signed</code> if <em>lhs</em>
and <em>rhs</em> validate as type <code>intish</code>.

<h4>ConditionalExpression</h4>

<p>A <em>ConditionalExpression</em> node

<div class="example">
<em>test:LogicalORExpression</em> <code>?</code> <em>cons:AssignmentExpression</em> <code>:</code> <em>alt:AssignmentExpression</em>
</div>

<p>validates as type &tau; if:

<ul>
<li>&tau; = <code>int</code> or &tau; = <code>double</code>;
<li><em>test</em> validates as type <code>int</code>;
<li><em>cons</em> and <em>alt</em> validate as subtypes of &tau;.
</ul>

<h4>Parenthesized Expression</h4>

<p>A parenthesized expression node

<div class="example">
<code>(</code> <em>expr:Expression</em> <code>)</code>
</div>

<p>validates as type &tau; if <em>expr</em> validates as type &tau;.


<h3>Function Calls</h3>

<p>Each function call expression is validated in the context of a
global environment &Delta; and a variable environment &Gamma;, and
validates against an <em>actual return type</em> &tau;, which was
provided from the context in which the function call appears. A
recursive validation of a subterm uses the same context as its
containing term.

<p>A <em>CallExpression</em> node

<div class="example">
<em>f:Identifier</em><code>(</code><em>arg:Expression</em><code>,</code>&hellip;<code>)</code>
</div>

<p>is valid with actual return type &tau; if <em>Lookup</em>(&Delta;,
&Gamma;, <em>f</em>) = &hellip; &and; (&sigma;,&hellip;) &rarr; &tau;
&and; &hellip; and each <em>arg</em> validates as a subtype of its
corresponding &sigma;.

<p>Alternatively, the <em>CallExpression</em> node is valid with
actual return type &tau; if <em>Lookup</em>(&Delta;,
&Gamma;, <em>f</em>) = <code>Function</code> and each <em>arg</em>
validates as a subtype of <code>extern</code>.

<!--
<div class="compilation">
<p>
Calls to local functions can be compiled to efficient code that enters
the well-typed body of functions, skipping past the dynamic type
coercions.
</p>

<p>
Calls to <code>stdlib</code> functions can be similarly compiled to
skip the dynamic type coercions of ECMAScript standard library
functions.
</p>

<p>
Calls to <code>foreign</code> functions, by contrast, require boxing
the internal representation of values as standard dynamic values in
whatever representation required by the JavaScript engine.
</p>
</div>
-->

<p>A <em>CallExpression</em> node

<div class="example">
<em>x:Identifier</em><code>[</code><em>index:Expression</em><code> &amp; </code><em>n:</em><code>-</code><span class="meta opt">?</span><em>NumericLiteral</em><code>](</code><em>arg:Expression</em><code>,</code>&hellip;<code>)</code>
</div>

<p>is valid with actual return type &tau; if:

<ul>
<li>the source of <em>n</em> does not contain a <code>.</code> character;
<li><em>Lookup</em>(&Delta;,
&Gamma;, <em>x</em>) = ((&sigma;,&hellip;) &rarr;
&tau;)[<em>n+1</em>];
<li><em>index</em> validates as a subtype of <code>intish</code>; and
<li>each <em>arg</em> validates as a subtype of its corresponding &sigma;.
</ul>

<!--
<div class="compilation">
<p>
Calls to function pointers 
</p>
</div>
-->

<h2>Linking</h2>

<p>An AOT implementation of asm.js must perform some internal dynamic
checks at link time to be able to safely generate AOT-compiled
exports. If any of the dynamic checks fails, the result of linking
cannot be an AOT-compiled module. The dynamically checked invariants
are:

<ul>
<li>control must reach the module's <code>return</code> statement without throwing;
<li>the <em>heap</em> object (if provided) must be an instance of <a href="https://developer.mozilla.org/en-US/docs/JavaScript/Typed_arrays/ArrayBuffer"><code>ArrayBuffer</code></a>;
<li>the <em>heap</em> object's <code>byteLength</code> must be a multiple of 4096;
<li>the <em>heap</em> object's <code>byteLength</code> must be a power of 2;
<li>the <em>heap</em> object's <code>byteLength</code> must be no greater than 2<sup>31</sup> (assuming the engine even allows <code>ArrayBuffer</code>s that large);
<li>all view objects must be true instances of their
respective <a href="https://developer.mozilla.org/en-US/docs/JavaScript/Typed_arrays/ArrayBufferView">typed
array</a> types;
<li>all globals taken from the <em>stdlib</em> object must implement
the semantics of the
corresponding <a href="http://ecma-international.org/ecma-262/5.1/#sec-15">standard
library</a> of the same name (in practice, they must be
the <a href="http://ecma-international.org/ecma-262/5.1/#sec-9.12">SameValue</a>
as the specified library function or value).
</ul>

<p>If any of these conditions is not met, it is generally unsafe to
produce an AOT-compiled module object, and the engine should fall back
to an interpreted or JIT-compiled implementation.

<h2>Operators</h2>

<h3>Unary Operators</h3>

<table>
<tbody>
<tr>
  <th>Unary Operator</th>
  <th>Type</th>
</tr>
<tr>
  <td><code>+</code></td>
  <td>
    (<code>signed</code>) &rarr; <code>double</code> &and;<br>
    (<code>unsigned</code>) &rarr; <code>double</code> &and;<br>
    (<code>doublish</code>) &rarr; <code>double</code>
  </td>
</tr>
<tr>
  <td><code>-</code></td>
  <td>
    (<code>int</code>) &rarr; <code>intish</code> &and;<br>
    (<code>doublish</code>) &rarr; <code>double</code>
  </td>
</tr>
<tr>
  <td><code>~</code></td>
  <td>(<code>intish</code>) &rarr; <code>signed</code></td>
</tr>
<tr>
  <td><code>!</code></td>
  <td>(<code>int</code>) &rarr; <code>int</code></td>
</tr>
</tbody>
</table>

<p>Note that the special combined operator <code>~~</code> may be used
as a coercion from <code>double</code> to <code>signed</code>;
see <a href="#unaryexpression">Unary Expressions</a>.

<h3>Binary Operators</h3>

<table>
<tbody>
<tr>
  <th>Binary Operator</th>
  <th>Type</th>
</tr>
<tr>
  <td><code>+</code></td>
  <td>(<code>double</code>, <code>double</code>) &rarr; <code>double</code></td>
</tr>
<tr>
  <td><code>-</code></td>
  <td>(<code>doublish</code>, <code>doublish</code>) &rarr; <code>double</code></td>
</tr>
<tr>
  <td><code>*</code></td>
  <td>(<code>doublish</code>, <code>doublish</code>) &rarr; <code>double</code></td>
</tr>
<tr>
  <td><code>/</code></td>
  <td>
    (<code>signed</code>, <code>signed</code>) &rarr; <code>intish</code> &and;<br>
    (<code>unsigned</code>, <code>unsigned</code>) &rarr; <code>intish</code> &and;<br>
    (<code>doublish</code>, <code>doublish</code>) &rarr; <code>double</code>
  </td>
</tr>
<tr>
  <td><code>%</code></td>
  <td>
    (<code>signed</code>, <code>signed</code>) &rarr; <code>intish</code> &and;<br>
    (<code>unsigned</code>, <code>unsigned</code>) &rarr; <code>intish</code> &and;<br>
    (<code>doublish</code>, <code>doublish</code>) &rarr; <code>double</code>
  </td>
</tr>
<tr>
  <td><code>|</code>, <code>&amp;</code>, <code>^</code>, <code>&lt;&lt;</code>, <code>&gt;&gt;</code></td>
  <td>(<code>intish</code>, <code>intish</code>) &rarr; <code>signed</code></td>
</tr>
<tr>
  <td><code>&gt;&gt;&gt;</code></td>
  <td>(<code>intish</code>, <code>intish</code>) &rarr; <code>unsigned</code></td>
</tr>
<tr>
  <td><code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, <code>&gt;=</code>, <code>==</code>, <code>!=</code></td>
  <td>
    (<code>signed</code>, <code>signed</code>) &rarr; <code>int</code> &and;<br>
    (<code>unsigned</code>, <code>unsigned</code>) &rarr; <code>int</code> &and;<br>
    (<code>double</code>, <code>double</code>) &rarr; <code>int</code>
  </td>
</tr>
</tbody>
</table>

<h2>Standard Library</h2>

<table>
<tbody>
<tr>
  <th>Standard Library</th>
  <th>Type</th>
</tr>
<tr>
  <td>
    <code>Infinity</code><br>
    <code>NaN</code>
  </td>
  <td><code>double</code></td>
</tr>
<tr>
  <td>
    <code>Math.acos</code><br>
    <code>Math.asin</code><br>
    <code>Math.atan</code><br>
    <code>Math.cos</code><br>
    <code>Math.sin</code><br>
    <code>Math.tan</code><br>
    <code>Math.ceil</code><br>
    <code>Math.floor</code><br>
    <code>Math.exp</code><br>
    <code>Math.log</code><br>
    <code>Math.sqrt</code>
  </td>
  <td>(<code>doublish</code>) &rarr; <code>double</code></td>
</tr>
<tr>
  <td><code>Math.abs</code></td>
  <td>
    (<code>signed</code>) &rarr; <code>unsigned</code> &and;<br>
    (<code>doublish</code>) &rarr; <code>double</code>
  </td>
</tr>
<tr>
  <td>
    <code>Math.atan2</code><br>
    <code>Math.pow</code>
  </td>
  <td>(<code>doublish</code>, <code>doublish</code>) &rarr; <code>double</code></td>
</tr>
<tr>
  <td><code>Math.imul</code></td>
  <td>(<code>int</code>, <code>int</code>) &rarr; <code>signed</code></td>
</tr>
<tr>
  <td>
    <code>Math.E</code><br>
    <code>Math.LN10</code><br>
    <code>Math.LN2</code><br>
    <code>Math.LOG2E</code><br>
    <code>Math.LOG10E</code><br>
    <code>Math.PI</code><br>
    <code>Math.SQRT1_2</code><br>
    <code>Math.SQRT2</code><br>
  </td>
  <td><code>double</code></td>
</tr>
</tbody>
</table>

<h2>Heap View Types</h2>

<table>
<tbody>
<tr>
  <th>View Type</th>
  <th>Element Size (Bytes)</th>
  <th>Element Type</th>
</tr>
<tr>
  <td><code>Uint8Array</code></td>
  <td>1</td>
  <td><code>intish</code></td>
</tr>
<tr>
  <td><code>Int8Array</code></td>
  <td>1</td>
  <td><code>intish</code></td>
</tr>
<tr>
  <td><code>Uint16Array</code></td>
  <td>2</td>
  <td><code>intish</code></td>
</tr>
<tr>
  <td><code>Int16Array</code></td>
  <td>2</td>
  <td><code>intish</code></td>
</tr>
<tr>
  <td><code>Uint32Array</code></td>
  <td>4</td>
  <td><code>intish</code></td>
</tr>
<tr>
  <td><code>Int32Array</code></td>
  <td>4</td>
  <td><code>intish</code></td>
</tr>
<tr>
  <td><code>Float32Array</code></td>
  <td>4</td>
  <td><code>doublish</code></td>
</tr>
<tr>
  <td><code>Float64Array</code></td>
  <td>8</td>
  <td><code>doublish</code></td>
</tr>
</tbody>
</table>

<h2 class="no-num">Acknowledgements</h2>

<p>Thanks to Martin Best, Brendan Eich, Andrew McCreight, and Vlad
Vuki&cacute;evi&cacute; for feedback and encouragement.</p>

<p>Thanks to Jesse Ruderman and C. Scott Ananian for bug reports.</p>

<p>Thanks to Michael Bebenita for diagrams.</p>

</body>
</html>
